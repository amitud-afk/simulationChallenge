---
title: "Simulation Challenge"
subtitle: "Starter Template with To-Dos"
format:
  html: default
execute:
  echo: true
  eval: true
---

# ðŸŽ² Simulation Challenge - Starter Template

:::: {.callout-important}
## ðŸ“‹ What You Need To Do

- [ ] Fork and create repo `simulationChallenge` in your GitHub
- [ ] Clone locally and open in Cursor
- [ ] Write your analysis in this `index.qmd`
- [ ] Render to HTML (`quarto render` or Render button)
- [ ] Push HTML to your repo and enable GitHub Pages
- [ ] Share your site: `https://[your-username].github.io/simulationChallenge/`
:::

:::: {.callout-warning}
## âš ï¸ AI Partnership Required
Use Cursor AI for speed, but ensure you understand and can explain the results in your own words.  Verify cursor's calculations as investment simulation is tricky.
:::

## The Investment Game (Brief)

You have the opportunity to buy-in to this game next week with $30,000. Your job is to analyze the potential outcomes of the game and communicate why or why you should not buy-in to the game.  

Each year after buy-in you flip a fair coin:

- Heads: increase your account balance by 50%
- Tails: decrease your account balance by 40%

You play annually until age 75. Your mission is to analyze outcomes and communicate insights clearly.

### Generative DAG Model (from the source challenge)

The following DAFT diagram shows the generative structure of the investment game over time.

```{python}
#| echo: false
#| include: false
import daft

# Create the DAG directly without custom class
investmentDAG = daft.PGM(dpi=100, alternate_style="outer")

# Initial wealth (deterministic)
investmentDAG.add_node("W0", "Initial Wealth\n$W_0 = 30,000$", x=4, y=2.5, aspect=5.4, 
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Time t nodes  
investmentDAG.add_node("Ct", "Coin Flip t\n$C_t \\sim \\text{Bernoulli}(0.5)$", x=0, y=1, aspect=4, scale = 1.6,
                      plot_params={'facecolor': 'aliceblue'})
investmentDAG.add_node("Wt", "\nWealth t\n$W_t = 1.5 \\times W_{t-1}$ if $C_t = 1$\n$W_t = 0.6 \\times W_{t-1}$ if $C_t = 0$\n", x=4, y=1, scale = 1.6, aspect=4,
                      alternate=True, plot_params={'facecolor': 'aliceblue'})

# Add edges showing the relationships
investmentDAG.add_edge("W0", "Wt")
investmentDAG.add_edge("Ct", "Wt")

# Add plate around time-dependent nodes
investmentDAG.add_plate([-2, 0.5, 7.8, 1.0], label="t = 1, ..., N", shift=-0.1)
```

```{python}
#| label: fig-investment-dag
#| fig-cap: Generative DAG model for the investment game showing how wealth evolves over time through coin flips
#| echo: false
investmentDAG.show()
```

## Analysis Tasks (Fill These In)

::::: {.callout-note}
## Grading Scope

- Sections 1â€“4: required and can earn up to 90% of the grade.
- Sections 5â€“6: optional; strong, well-supported work here can bring your score up to 100%.
::::

### 1) Expected Value After 1 Flip

TODO: Explain whether the expected value of your account balance after one flip is >, =, or < $30,000. What is the gain in expected value as a percentage of your buy-in? Does this simple analysis suggest you should buy-in to the game?

```{python}
#| label: q1-expected-value-py
#| echo: true

initial_balance = 30000
mult_heads = 1.5
mult_tails = 0.6
prob_heads = 0.5
prob_tails = 0.5

ev_after_one = prob_heads * (mult_heads * initial_balance) + prob_tails * (mult_tails * initial_balance)
percent_gain = (ev_after_one - initial_balance) / initial_balance

print(f"Expected value after one flip: ${ev_after_one:,.0f}")
print(f"Gain vs. $30,000: {percent_gain:.1%}")
print("Explanation: EV = 0.5Ã—(1.5Ã—30,000) + 0.5Ã—(0.6Ã—30,000) = 31,500 â†’ +5%.")

```

### 2) Single Simulation Over Time (Narrative + Plot)

Briefly narrate and visualize what happens to your account balance over the course of one run. Are you happy with the outcome? Why? or Why not?  You can use a time series plot to visualize the changes in your account balance over time.

```{python}
#| label: q2-single-sim-py
#| echo: true
#| fig-cap: "Single simulation path of account balance"

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import StrMethodFormatter

# Set seed for reproducibility
np.random.seed(25)

initial_balance = 30000
num_periods = 45  # N periods

# Simulate one path
wealth_by_period = np.empty(num_periods + 1, dtype=float)
wealth_by_period[0] = initial_balance
coin_flips = np.random.randint(0, 2, size=num_periods)  # 1=heads, 0=tails

for period_index in range(1, num_periods + 1):
    is_heads = coin_flips[period_index - 1] == 1
    growth_multiplier = 1.5 if is_heads else 0.6
    wealth_by_period[period_index] = wealth_by_period[period_index - 1] * growth_multiplier

# OO Matplotlib time-series plot
fig, ax = plt.subplots(figsize=(8, 4))
ax.plot(range(num_periods + 1), wealth_by_period, marker="o", linewidth=1.6)
ax.set_xlabel("Period")
ax.set_ylabel("Balance ($)")
ax.set_title("Single Simulation Path (seed=25)")
ax.yaxis.set_major_formatter(StrMethodFormatter('${x:,.0f}'))
ax.grid(True, alpha=0.3)

```

### 3) 100 Simulations: Distribution of Final Balances

TODO: Visually and narratively describe the distribution of your account balance after running the 100 simulations. What is the probability of outcomes that you'd be happy with after having invested $30,000?

```{python}
#| label: q3-dist-100-py
#| echo: true
#| fig-cap: "Distribution of final balances across 100 simulations"

import numpy as np
import matplotlib.pyplot as plt
from matplotlib.ticker import StrMethodFormatter

# Reproducibility
np.random.seed(25)

# Game parameters
initial_balance = 30000
num_periods = 45  # years to age 75 if starting at ~30
num_sims = 100
mult_heads = 1.5
mult_tails = 0.6

# Vectorized simulation of terminal wealths
balances = np.full(shape=num_sims, fill_value=initial_balance, dtype=float)
coin_flips = np.random.randint(0, 2, size=(num_periods, num_sims))  # 1=heads, 0=tails
for t in range(num_periods):
    step_mult = np.where(coin_flips[t] == 1, mult_heads, mult_tails)
    balances *= step_mult

# Store for later sections
final_balances = balances.copy()

# Summary statistics
mean_final = float(np.mean(final_balances))
median_final = float(np.median(final_balances))
prob_gt_30k = float(np.mean(final_balances > initial_balance))

print(f"Mean final balance: ${mean_final:,.0f}")
print(f"Median final balance: ${median_final:,.0f}")
print(f"P(final > $30,000): {prob_gt_30k:.3f}")

# Histogram
fig, ax = plt.subplots(figsize=(8, 4))
ax.hist(final_balances, bins=30, color="#4C78A8", alpha=0.9, edgecolor="white")
ax.axvline(initial_balance, color="#E45756", linestyle="--", linewidth=2, label="$30,000 buy-in")
ax.axvline(mean_final, color="#72B7B2", linestyle=":", linewidth=2, label=f"Mean = ${mean_final:,.0f}")
ax.axvline(median_final, color="#F58518", linestyle="-.", linewidth=2, label=f"Median = ${median_final:,.0f}")
ax.set_xlabel("Final Balance ($)")
ax.set_ylabel("Count (out of 100)")
ax.set_title("Final Balances Across 100 Simulations")
ax.yaxis.set_major_formatter(StrMethodFormatter('{x:,.0f}'))
ax.xaxis.set_major_formatter(StrMethodFormatter('${x:,.0f}'))
ax.grid(True, alpha=0.25)
ax.legend(frameon=False)

```

Based on the 100 simulations, the distribution of terminal balances is highly skewed to the right: a small fraction of runs end extremely high, while many runs end below the buy-in. The mean is pulled up by rare big winners, but the median sits near or below the buyâ€‘in, reflecting that a â€œtypicalâ€ run is not spectacular. If your happiness threshold is simply ending above $30,000, the estimated probability above shows how often that happens; whether thatâ€™s satisfying depends on your risk tolerance for the many runs that fall short in pursuit of the occasional large upside.

### 4) Probability Balance > $30,000 at Age 75 (Original Game)

TODO: Report the probability estimate and interpret its practical meaning.

```{python}
#| label: q4-prob-original-py
#| echo: true

import numpy as np

try:
    prob_gt_30k_q4 = float(np.mean(final_balances > 30000))
    print(f"Estimated P(final > $30,000): {prob_gt_30k_q4:.3f}")
except NameError:
    print("Run the 100-simulation cell first to compute final_balances.")

```

### 5) Modified Strategy (Bet Exactly 50% Each Round)

Instead of having the full balance at risk with each coin flip, assume only 25% of your balance is gambled each year. Compare this to the original game. Which is riskier? Which has better upside?

```{python}
#| label: q5-modified-50pct-py
#| echo: true
#| fig-cap: "Modified strategy distribution (bet 50% each round)"

# TODO: Implement the modified game
# - Run 100 simulations; plot distribution of final balances
# - Estimate P(final > 30000) and compare to original
# - visually compare the outcome distributions of the original and modified strategies

```

### 6) Briefly Explain Your Findings From The Previous Step in Light of A Concept Known as the "Kelly Criterion"
 
What is the Kelly Criterion and how does it relate to the modified strategy?


## Professional Presentation (From Grading TLDR)

- **Clear narrative:** tell the story succinctly (aim for a 1â€“5 minute read)
- **Focus on insights:** risk profiles, counter-intuitive results, practical implications
- **Professional style:** concise writing, clean visuals, hide code where appropriate (`echo: false`)
- **Human interpretation:** explain what results mean for real decisions

## Submission Checklist âœ…

- [ ] Quarto document written with narrative and results
- [ ] Rendered to HTML successfully
- [ ] Repository `simulationChallenge` created on GitHub
- [ ] HTML committed and pushed
- [ ] GitHub Pages enabled (Deploy from a branch â†’ main â†’ /(root))
- [ ] Site accessible at `https://[your-username].github.io/simulationChallenge/`

## Tips

- Set random seeds for reproducibility
- Use object-oriented plotting with `matplotlib`
- Keep figures readable and labeled; prefer professional styling
- Commit early and often; render locally before pushing

